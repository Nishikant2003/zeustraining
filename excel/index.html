<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clean Grid</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: auto;
        }

        .scroll-content {
            position: relative;
        }

        canvas {
            position: sticky;
            top: 0;
            left: 0;
            display: block;
            cursor: cell;
            pointer-events: auto;
        }

        canvas.resize-col {
            cursor: col-resize;
        }

        canvas.resize-row {
            cursor: row-resize;
        }

        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
        }

        .cell-editor {
            position: fixed;
            border: 2px solid #4CAF50;
            background: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            padding: 2px 4px;
            margin: 0;
            outline: none;
            z-index: 200;
            box-sizing: border-box;
        }
    </style>
</head>

<body>
    <div class="container" id="container">
        <div class="scroll-content" id="scrollContent">
            <canvas id="grid"></canvas>
        </div>
    </div>
    <div class="info" id="info">Loading data...</div>

    <script>
        function getColumnName(col) {
            if (col === 0) return "";
            col = col - 1;
            let result = '';
            while (col >= 0) {
                result = String.fromCharCode(65 + (col % 26)) + result;
                col = Math.floor(col / 26) - 1;
            }
            return result;
        }

        function getCellAddress(row, col) {
            if (row === 0 && col === 0) return "A0";
            if (row === 0) return getColumnName(col) + "0";
            if (col === 0) return "0";
            return getColumnName(col) + row;
        }

        // Command Pattern Implementation
        class Command {
            constructor(description = "Unknown Command") {
                this.description = description;
                this.timestamp = Date.now();
            }

            execute() {
                throw new Error("Execute method must be implemented");
            }

            undo() {
                throw new Error("Undo method must be implemented");
            }

            canMerge(otherCommand) {
                return false;
            }

            merge(otherCommand) {
                // Override in subclasses that support merging
            }
        }

        class EditCellCommand extends Command {
            constructor(grid, row, col, newValue, oldValue) {
                super(`Edit ${getCellAddress(row, col)}: "${oldValue}" → "${newValue}"`);
                this.grid = grid;
                this.row = row;
                this.col = col;
                this.newValue = newValue;
                this.oldValue = oldValue;
            }

            execute() {
                this.grid.setCellValueDirect(this.row, this.col, this.newValue);
                this.grid.requestRender();
            }

            undo() {
                this.grid.setCellValueDirect(this.row, this.col, this.oldValue);
                this.grid.requestRender();
            }

            canMerge(otherCommand) {
                return otherCommand instanceof EditCellCommand &&
                       otherCommand.row === this.row &&
                       otherCommand.col === this.col &&
                       (Date.now() - this.timestamp) < 2000;
            }

            merge(otherCommand) {
                this.newValue = otherCommand.newValue;
                this.timestamp = otherCommand.timestamp;
                this.description = `Edit ${getCellAddress(this.row, this.col)}: "${this.oldValue}" → "${this.newValue}"`;
            }
        }

        class CommandManager {
            constructor(maxHistorySize = 100) {
                this.undoStack = [];
                this.redoStack = [];
                this.maxHistorySize = maxHistorySize;
                this.isExecuting = false;
            }

            executeCommand(command) {
                if (this.isExecuting) return;

                this.isExecuting = true;
                
                try {
                    const lastCommand = this.undoStack[this.undoStack.length - 1];
                    if (lastCommand && lastCommand.canMerge && lastCommand.canMerge(command)) {
                        lastCommand.merge(command);
                        command.execute();
                    } else {
                        command.execute();
                        this.undoStack.push(command);
                        
                        if (this.undoStack.length > this.maxHistorySize) {
                            this.undoStack.shift();
                        }
                    }
                    
                    this.redoStack = [];
                    
                } finally {
                    this.isExecuting = false;
                }
            }

            undo() {
                if (this.undoStack.length === 0) return false;
                
                const command = this.undoStack.pop();
                command.undo();
                this.redoStack.push(command);
                
                return true;
            }

            redo() {
                if (this.redoStack.length === 0) return false;
                
                const command = this.redoStack.pop();
                command.execute();
                this.undoStack.push(command);
                
                return true;
            }

            canUndo() {
                return this.undoStack.length > 0;
            }

            canRedo() {
                return this.redoStack.length > 0;
            }
        }

        class Selection {
            constructor() {
                this.selectedCells = new Set();
                this.isDragging = false;
                this.dragStartRow = -1;
                this.dragStartCol = -1;
                this.dragEndRow = -1;
                this.dragEndCol = -1;
                this.currentSelection = null;
            }

            clearSelection() {
                this.selectedCells.clear();
                this.currentSelection = null;
            }

            addCellToSelection(row, col) {
                this.selectedCells.add(`${row},${col}`);
            }

            isCellSelected(row, col) {
                return this.selectedCells.has(`${row},${col}`);
            }

            isRowHighlighted(row) {
                if (!this.currentSelection) return false;
                return row >= this.currentSelection.startRow && row <= this.currentSelection.endRow;
            }

            isColumnHighlighted(col) {
                if (!this.currentSelection) return false;
                return col >= this.currentSelection.startCol && col <= this.currentSelection.endCol;
            }

            selectRange(startRow, startCol, endRow, endCol) {
                this.clearSelection();
                
                const minRow = Math.min(startRow, endRow);
                const maxRow = Math.max(startRow, endRow);
                const minCol = Math.min(startCol, endCol);
                const maxCol = Math.max(startCol, endCol);
                
                for (let row = minRow; row <= maxRow; row++) {
                    for (let col = minCol; col <= maxCol; col++) {
                        this.addCellToSelection(row, col);
                    }
                }
                
                this.currentSelection = {
                    startRow: minRow,
                    startCol: minCol,
                    endRow: maxRow,
                    endCol: maxCol
                };
            }

            startDragSelection(row, col) {
                this.isDragging = true;
                this.dragStartRow = row;
                this.dragStartCol = col;
                this.dragEndRow = row;
                this.dragEndCol = col;
                this.selectRange(row, col, row, col);
            }

            updateDragSelection(row, col) {
                if (!this.isDragging) return;
                
                this.dragEndRow = row;
                this.dragEndCol = col;
                this.selectRange(this.dragStartRow, this.dragStartCol, this.dragEndRow, this.dragEndCol);
            }

            finishDragSelection() {
                this.isDragging = false;
            }

            getSelectionInfo() {
                if (!this.currentSelection) return "No selection";
                
                const { startRow, startCol, endRow, endCol } = this.currentSelection;
                const cellCount = (endRow - startRow + 1) * (endCol - startCol + 1);
                
                if (cellCount === 1) {
                    return `Cell: ${getCellAddress(startRow, startCol)}`;
                } else {
                    return `Range: ${getCellAddress(startRow, startCol)}:${getCellAddress(endRow, endCol)} (${cellCount} cells)`;
                }
            }

            getCurrentSelection() {
                return this.currentSelection;
            }

            getSelectedCellsArray() {
                return Array.from(this.selectedCells).map(cellStr => {
                    const [row, col] = cellStr.split(',').map(Number);
                    return { row, col };
                });
            }
        }

        class SelectionCalculator {
            constructor() {
                this.cache = new Map();
                this.cacheKey = null;
            }

            getNumericValues(grid, selection) {
                const selectedCells = selection.getSelectedCellsArray();
                const values = [];
                
                for (const { row, col } of selectedCells) {
                    if (row === 0 || col === 0) continue;
                    
                    const cell = grid.getCell(row, col);
                    const value = cell.getValue();
                    
                    if (value !== null && value !== undefined && value !== '') {
                        const numValue = this.parseNumber(value);
                        if (!isNaN(numValue)) {
                            values.push(numValue);
                        }
                    }
                }
                
                return values;
            }

            parseNumber(value) {
                if (typeof value === 'number') return value;
                
                const str = String(value).trim();
                
                if (str.endsWith('%')) {
                    return parseFloat(str.slice(0, -1)) / 100;
                }
                
                const cleaned = str.replace(/[$,€£¥]/g, '');
                
                if (cleaned.startsWith('(') && cleaned.endsWith(')')) {
                    return -parseFloat(cleaned.slice(1, -1));
                }
                
                return parseFloat(cleaned);
            }

            calculate(grid, selection) {
                const values = this.getNumericValues(grid, selection);
                
                const stats = {
                    count: values.length,
                    sum: 0,
                    min: null,
                    max: null,
                    avg: null,
                    hasNumbers: values.length > 0
                };

                if (values.length === 0) {
                    return stats;
                }

                stats.sum = values.reduce((acc, val) => acc + val, 0);
                stats.min = Math.min(...values);
                stats.max = Math.max(...values);
                stats.avg = stats.sum / stats.count;
                
                return stats;
            }

            getFormattedStats(grid, selection) {
                const stats = this.calculate(grid, selection);
                
                if (!stats.hasNumbers) {
                    return "No numeric values selected";
                }

                const parts = [];
                
                if (stats.count === 1) {
                    parts.push(`Value: ${this.formatNumber(stats.sum)}`);
                } else {
                    parts.push(`Count: ${stats.count}`);
                    parts.push(`Sum: ${this.formatNumber(stats.sum)}`);
                    parts.push(`Avg: ${this.formatNumber(stats.avg)}`);
                    parts.push(`Min: ${this.formatNumber(stats.min)}`);
                    parts.push(`Max: ${this.formatNumber(stats.max)}`);
                }
                
                return parts.join(' | ');
            }

            formatNumber(num) {
                if (num === null || num === undefined) return 'N/A';
                
                if (Math.abs(num) < 0.01 && num !== 0) {
                    return num.toExponential(2);
                }
                
                if (num % 1 === 0) {
                    return num.toLocaleString();
                }
                
                return num.toLocaleString(undefined, { 
                    minimumFractionDigits: 0, 
                    maximumFractionDigits: 2 
                });
            }

            clearCache() {
                this.cache.clear();
                this.cacheKey = null;
            }
        }

        class Cell {
            constructor(row, col, value = null) {
                this.row = row;
                this.col = col;
                this.value = value;
            }

            getValue() {
                if (this.value !== null) return this.value;

                if (this.row === 0 && this.col === 0) return '';
                if (this.row === 0) return this.getColumnHeader();
                if (this.col === 0) return this.row.toString();
                return '';
            }

            setValue(value) {
                this.value = value;
            }

            getColumnHeader() {
                if (this.col === 0) return '';
                return getColumnName(this.col);
            }

            isHeader() {
                return this.row === 0 || this.col === 0;
            }

            getBackgroundColor(selection) {
                if (this.isHeader()) {
                    if ((this.row === 0 && selection.isColumnHighlighted(this.col)) || 
                        (this.col === 0 && selection.isRowHighlighted(this.row))) {
                        return '#BBDEFB';
                    }
                    return '#f0f0f0';
                }
                if (selection.isCellSelected(this.row, this.col)) return '#E3F2FD';
                return '#ffffff';
            }

            getTextColor() {
                return this.isHeader() ? '#333' : '#000';
            }

            draw(ctx, x, y, width, height, selection) {
                ctx.fillStyle = this.getBackgroundColor(selection);
                ctx.fillRect(x, y, width, height);

                if (selection.isCellSelected(this.row, this.col) && !this.isHeader()) {
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 1, y + 1, width - 2, height - 2);
                }

                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, width, height);

                ctx.fillStyle = this.getTextColor();
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';

                const text = this.getValue();
                const maxWidth = width - 8;

                ctx.save();
                ctx.beginPath();
                ctx.rect(x + 2, y, width - 4, height);
                ctx.clip();

                ctx.fillText(text, x + 4, y + height / 2, maxWidth);
                ctx.restore();
            }
        }

        class RowColumn {
            constructor(index, type, cellCount) {
                this.index = index;
                this.type = type;
                this.cellCount = cellCount;
                this.cells = new Map();
                this.size = type === 'row' ? 25 : 100;
            }

            getCell(cellIndex) {
                if (!this.cells.has(cellIndex)) {
                    const [row, col] = this.type === 'row'
                        ? [this.index, cellIndex]
                        : [cellIndex, this.index];
                    this.cells.set(cellIndex, new Cell(row, col));
                }
                return this.cells.get(cellIndex);
            }

            setCellValue(cellIndex, value) {
                const cell = this.getCell(cellIndex);
                cell.setValue(value);
            }

            setSize(newSize) {
                this.size = Math.max(10, newSize);
            }

            getSize() {
                return this.size;
            }
        }

        class CanvasGrid {
            constructor(canvasId, rowCount, colCount) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('container');
                this.scrollContent = document.getElementById('scrollContent');
                this.info = document.getElementById('info');
                
                this.rowCount = rowCount;
                this.colCount = colCount;
                this.scrollX = 0;
                this.scrollY = 0;

                // Data storage
                this.data = [];
                this.dataColumns = ['id', 'firstName', 'lastName', 'age', 'salary'];

                // Initialize systems
                this.commandManager = new CommandManager();
                this.selection = new Selection();
                this.calculator = new SelectionCalculator();

                // Initialize data structures
                this.rows = new Map();
                this.columns = new Map();

                // Virtual rendering properties
                this.visibleRows = 0;
                this.visibleCols = 0;
                this.startRow = 0;
                this.endRow = 0;
                this.startCol = 0;
                this.endCol = 0;

                // Performance optimization
                this.renderRequested = false;
                this.scrollTimeout = null;
                this.lastScrollTime = 0;
                this.scrollThrottle = 16;

                // Cached position arrays
                this.rowPositions = [];
                this.colPositions = [];

                // State
                this.isResizing = false;
                this.resizeType = null;
                this.resizeIndex = -1;
                this.resizeStartPos = 0;
                this.resizeStartSize = 0;

                this.isEditing = false;
                this.editingCell = null;
                this.editor = null;
                this.editorBlurHandler = null;
                this.editorKeyHandler = null;

                // Initialize
                this.initializeStructures();
                this.setupCanvas();
                this.buildPositionCaches();
                this.setupScrollArea();
                this.bindEvents();
                this.updateScrollPosition();
                this.calculateVisibleRange();
                this.render();
            }

            initializeStructures() {
                for (let i = 0; i < this.colCount; i++) {
                    this.columns.set(i, new RowColumn(i, 'column', this.rowCount));
                }
                
                for (let i = 0; i < this.rowCount; i++) {
                    this.rows.set(i, new RowColumn(i, 'row', this.colCount));
                }
            }

            buildPositionCaches() {
                this.rowPositions = [0];
                for (let i = 0; i < this.rowCount; i++) {
                    const rowHeight = this.getRow(i).getSize();
                    this.rowPositions.push(this.rowPositions[i] + rowHeight);
                }

                this.colPositions = [0];
                for (let i = 0; i < this.colCount; i++) {
                    const colWidth = this.getColumn(i).getSize();
                    this.colPositions.push(this.colPositions[i] + colWidth);
                }
            }

            getRow(index) {
                if (!this.rows.has(index)) {
                    this.rows.set(index, new RowColumn(index, 'row', this.colCount));
                }
                return this.rows.get(index);
            }

            getColumn(index) {
                if (!this.columns.has(index)) {
                    this.columns.set(index, new RowColumn(index, 'column', this.rowCount));
                }
                return this.columns.get(index);
            }

            getCell(row, col) {
                return this.getRow(row).getCell(col);
            }

            setCellValueDirect(row, col, value) {
                this.getRow(row).setCellValue(col, value);
                this.calculator.clearCache();
            }

            setCellValue(row, col, value) {
                const oldValue = this.getCell(row, col).getValue();
                if (oldValue !== value) {
                    const command = new EditCellCommand(this, row, col, value, oldValue);
                    this.commandManager.executeCommand(command);
                }
            }

            // Load data from JSON
            async loadData(url = 'data.json') {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    this.populateGridWithData(data);
                    this.info.textContent = `Loaded ${data.length} records `;
                    
                } catch (error) {
                    console.error('Error loading data:', error);
                    this.info.textContent = `Ready - ${this.rowCount-2} rows available for data`;
                }
            }

            populateGridWithData(data) {
                this.data = data;
                
                // Set column headers in row 1 (not row 0!)
                this.dataColumns.forEach((colName, index) => {
                    this.setCellValueDirect(1, index + 1, colName.charAt(0).toUpperCase() + colName.slice(1));
                });

                // Populate data rows starting from row 2 (not row 1!)
                data.forEach((record, rowIndex) => {
                    const actualRow = rowIndex + 2; // Start from row 2, not row 1
                    
                    this.dataColumns.forEach((colName, colIndex) => {
                        const actualCol = colIndex + 1; // Start from column 1, not column 0
                        const value = record[colName];
                        this.setCellValueDirect(actualRow, actualCol, String(value));
                    });
                });

                this.requestRender();
            }

            setupCanvas() {
                this.canvas.width = this.container.clientWidth;
                this.canvas.height = this.container.clientHeight;
                
                this.visibleRows = Math.ceil(this.canvas.height / 25) + 5;
                this.visibleCols = Math.ceil(this.canvas.width / 100) + 5;
            }

            updateScrollPosition() {
                this.scrollX = this.container.scrollLeft;
                this.scrollY = this.container.scrollTop;
                
                // Update editor position if editing
                if (this.isEditing && this.editingCell) {
                    this.positionEditor(this.editingCell.row, this.editingCell.col);
                }
            }

            calculateVisibleRange() {
                this.startRow = this.binarySearchPosition(this.rowPositions, this.scrollY);
                this.startRow = Math.max(0, this.startRow - 2);

                this.endRow = this.binarySearchPosition(this.rowPositions, this.scrollY + this.canvas.height);
                this.endRow = Math.min(this.rowCount - 1, this.endRow + 2);

                this.startCol = this.binarySearchPosition(this.colPositions, this.scrollX);
                this.startCol = Math.max(0, this.startCol - 2);

                this.endCol = this.binarySearchPosition(this.colPositions, this.scrollX + this.canvas.width);
                this.endCol = Math.min(this.colCount - 1, this.endCol + 2);
            }

            binarySearchPosition(positions, target) {
                let left = 0;
                let right = positions.length - 1;
                
                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    if (positions[mid] <= target) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
                
                return Math.max(0, right);
            }

            setupScrollArea() {
                const totalWidth = this.colPositions[this.colPositions.length - 1];
                const totalHeight = this.rowPositions[this.rowPositions.length - 1];
                
                this.scrollContent.style.width = totalWidth + 'px';
                this.scrollContent.style.height = totalHeight + 'px';
            }

            getColumnPosition(colIndex) {
                return this.colPositions[colIndex] || 0;
            }

            getRowPosition(rowIndex) {
                return this.rowPositions[rowIndex] || 0;
            }

            getColumnAtPosition(x) {
                return this.binarySearchPosition(this.colPositions, x);
            }

            getRowAtPosition(y) {
                return this.binarySearchPosition(this.rowPositions, y);
            }

            getCellAtPosition(x, y) {
                let col, row;
                
                if (x < this.getColumn(0).getSize()) {
                    col = 0;
                    if (y < this.getRow(0).getSize()) {
                        row = 0;
                    } else {
                        row = this.getRowAtPosition(y + this.scrollY);
                    }
                } else if (y < this.getRow(0).getSize()) {
                    row = 0;
                    col = this.getColumnAtPosition(x + this.scrollX);
                } else {
                    col = this.getColumnAtPosition(x + this.scrollX);
                    row = this.getRowAtPosition(y + this.scrollY);
                }

                return { row, col };
            }

            requestRender() {
                if (!this.renderRequested) {
                    this.renderRequested = true;
                    requestAnimationFrame(() => {
                        this.render();
                        this.renderRequested = false;
                    });
                }
            }

            handleScroll() {
                const now = performance.now();
                if (now - this.lastScrollTime < this.scrollThrottle) {
                    if (this.scrollTimeout) {
                        clearTimeout(this.scrollTimeout);
                    }
                    this.scrollTimeout = setTimeout(() => {
                        this.updateScrollPosition();
                        this.calculateVisibleRange();
                        this.requestRender();
                    }, this.scrollThrottle);
                    return;
                }

                this.lastScrollTime = now;
                this.updateScrollPosition();
                this.calculateVisibleRange();
                this.requestRender();
            }

            bindEvents() {
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.buildPositionCaches();
                    this.setupScrollArea();
                    this.calculateVisibleRange();
                    this.requestRender();
                });

                this.container.addEventListener('scroll', () => {
                    this.handleScroll();
                }, { passive: true });

                this.canvas.addEventListener('mousedown', (e) => {
                    if (this.isEditing) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Check for resize handles first
                    const resizeInfo = this.getResizeHandle(x, y);
                    if (resizeInfo) {
                        this.startResize(resizeInfo, e.clientX, e.clientY);
                        return;
                    }
                    
                    const cellPos = this.getCellAtPosition(x, y);
                    if (cellPos.row >= 0 && cellPos.row < this.rowCount && 
                        cellPos.col >= 0 && cellPos.col < this.colCount) {
                        
                        // Handle row header click (select entire row)
                        if (cellPos.col === 0 && cellPos.row > 0) {
                            this.selection.selectRange(cellPos.row, 1, cellPos.row, this.colCount - 1);
                            this.updateInfoDisplay();
                            this.requestRender();
                        }
                        // Handle column header click (select entire column)  
                        else if (cellPos.row === 0 && cellPos.col > 0) {
                            this.selection.selectRange(1, cellPos.col, this.rowCount - 1, cellPos.col);
                            this.updateInfoDisplay();
                            this.requestRender();
                        }
                        // Handle corner click (select all)
                        else if (cellPos.row === 0 && cellPos.col === 0) {
                            this.selection.selectRange(1, 1, this.rowCount - 1, this.colCount - 1);
                            this.updateInfoDisplay();
                            this.requestRender();
                        }
                        // Handle regular cell click (start drag selection)
                        else if (cellPos.row > 0 && cellPos.col > 0) {
                            this.selection.startDragSelection(cellPos.row, cellPos.col);
                            this.updateInfoDisplay();
                            this.requestRender();
                        }
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    if (this.isResizing) {
                        this.handleResize(e.clientX, e.clientY);
                        return;
                    }
                    
                    if (this.selection.isDragging) {
                        const cellPos = this.getCellAtPosition(x, y);
                        if (cellPos.row > 0 && cellPos.col > 0) {
                            this.selection.updateDragSelection(cellPos.row, cellPos.col);
                            this.updateInfoDisplay();
                            this.requestRender();
                        }
                        return;
                    }
                    
                    // Update cursor for resize handles
                    const resizeInfo = this.getResizeHandle(x, y);
                    if (resizeInfo) {
                        this.canvas.className = resizeInfo.type === 'column' ? 'resize-col' : 'resize-row';
                    } else {
                        this.canvas.className = '';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (this.selection.isDragging) {
                        this.selection.finishDragSelection();
                    }
                    if (this.isResizing) {
                        this.stopResize();
                    }
                });

                this.canvas.addEventListener('dblclick', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const cellPos = this.getCellAtPosition(x, y);
                    if (cellPos.row > 0 && cellPos.col > 0) {
                        this.startEditing(cellPos.row, cellPos.col);
                    }
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (this.isEditing) return;
                    
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z' || e.key === 'Z') {
                            if (e.shiftKey) {
                                this.commandManager.redo();
                            } else {
                                this.commandManager.undo();
                            }
                            e.preventDefault();
                        } else if (e.key === 'y' || e.key === 'Y') {
                            this.commandManager.redo();
                            e.preventDefault();
                        }
                    }
                });
            }

            startEditing(row, col) {
                if (this.isEditing) {
                    this.stopEditing(true);
                }

                this.isEditing = true;
                this.editingCell = { row, col };
                
                this.editor = document.createElement('input');
                this.editor.type = 'text';
                this.editor.className = 'cell-editor';
                this.editor.value = this.getCell(row, col).getValue();
                
                this.positionEditor(row, col);
                
                document.body.appendChild(this.editor);
                this.editor.focus();
                this.editor.select();
                
                this.editorKeyHandler = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.stopEditing(true);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        this.stopEditing(false);
                    }
                };
                
                this.editorBlurHandler = () => {
                    setTimeout(() => {
                        if (this.isEditing) {
                            this.stopEditing(true);
                        }
                    }, 10);
                };
                
                this.editor.addEventListener('keydown', this.editorKeyHandler);
                this.editor.addEventListener('blur', this.editorBlurHandler);
            }

            stopEditing(save = true) {
                if (!this.isEditing || !this.editor) return;
                
                if (this.editorKeyHandler) {
                    this.editor.removeEventListener('keydown', this.editorKeyHandler);
                    this.editorKeyHandler = null;
                }
                if (this.editorBlurHandler) {
                    this.editor.removeEventListener('blur', this.editorBlurHandler);
                    this.editorBlurHandler = null;
                }
                
                if (save && this.editingCell) {
                    const newValue = this.editor.value;
                    this.setCellValue(this.editingCell.row, this.editingCell.col, newValue);
                }
                
                if (this.editor && this.editor.parentNode) {
                    this.editor.parentNode.removeChild(this.editor);
                }
                
                this.isEditing = false;
                this.editingCell = null;
                this.editor = null;
                
                this.requestRender();
            }

            positionEditor(row, col) {
                if (!this.editor) return;
                
                const rect = this.canvas.getBoundingClientRect();
                
                // Calculate cell position relative to the canvas
                let cellX = this.getColumnPosition(col) - this.scrollX;
                let cellY = this.getRowPosition(row) - this.scrollY;
                
                // Handle frozen headers - if cell is in frozen area, don't subtract scroll
                if (col === 0) {
                    cellX = this.getColumnPosition(col);
                }
                if (row === 0) {
                    cellY = this.getRowPosition(row);
                }
                
                // Convert to screen coordinates
                const screenX = rect.left + cellX;
                const screenY = rect.top + cellY;
                
                const width = this.getColumn(col).getSize();
                const height = this.getRow(row).getSize();
                
                // Check if cell is visible
                const isVisible = cellX >= 0 && cellY >= 0 && 
                                cellX < this.canvas.width && cellY < this.canvas.height;
                
                if (isVisible) {
                    this.editor.style.left = screenX + 'px';
                    this.editor.style.top = screenY + 'px';
                    this.editor.style.width = (width - 2) + 'px';
                    this.editor.style.height = (height - 2) + 'px';
                    this.editor.style.display = 'block';
                } else {
                    // Hide editor if cell is not visible
                    this.editor.style.display = 'none';
                }
            }

            getResizeHandle(x, y) {
                const tolerance = 5;
                
                // Check column resize handles (right edge of column headers)
                if (y <= this.getRow(0).getSize()) {
                    for (let col = this.startCol; col <= this.endCol && col < this.colCount; col++) {
                        if (col === 0) continue;
                        const colRight = this.getColumnPosition(col + 1) - this.scrollX;
                        if (Math.abs(x - colRight) <= tolerance) {
                            return { type: 'column', index: col };
                        }
                    }
                }
                
                // Check row resize handles (bottom edge of row headers)
                if (x <= this.getColumn(0).getSize()) {
                    for (let row = this.startRow; row <= this.endRow && row < this.rowCount; row++) {
                        if (row === 0) continue;
                        const rowBottom = this.getRowPosition(row + 1) - this.scrollY;
                        if (Math.abs(y - rowBottom) <= tolerance) {
                            return { type: 'row', index: row };
                        }
                    }
                }
                
                return null;
            }

            startResize(resizeInfo, clientX, clientY) {
                this.isResizing = true;
                this.resizeType = resizeInfo.type;
                this.resizeIndex = resizeInfo.index;
                this.resizeStartPos = resizeInfo.type === 'column' ? clientX : clientY;
                
                if (resizeInfo.type === 'column') {
                    this.resizeStartSize = this.getColumn(resizeInfo.index).getSize();
                } else {
                    this.resizeStartSize = this.getRow(resizeInfo.index).getSize();
                }
                
                // Prevent text selection during resize
                document.body.style.userSelect = 'none';
            }

            handleResize(clientX, clientY) {
                if (!this.isResizing) return;
                
                const currentPos = this.resizeType === 'column' ? clientX : clientY;
                const delta = currentPos - this.resizeStartPos;
                const newSize = Math.max(20, this.resizeStartSize + delta);
                
                if (this.resizeType === 'column') {
                    this.getColumn(this.resizeIndex).setSize(newSize);
                } else {
                    this.getRow(this.resizeIndex).setSize(newSize);
                }
                
                this.buildPositionCaches();
                this.setupScrollArea();
                this.calculateVisibleRange();
                
                // Update editor position if editing
                if (this.isEditing && this.editingCell) {
                    this.positionEditor(this.editingCell.row, this.editingCell.col);
                }
                
                this.requestRender();
            }

            stopResize() {
                if (!this.isResizing) return;
                
                this.isResizing = false;
                this.resizeType = null;
                this.resizeIndex = -1;
                this.resizeStartPos = 0;
                this.resizeStartSize = 0;
                
                // Re-enable text selection
                document.body.style.userSelect = '';
                this.canvas.className = '';
            }

            render() {
                const { ctx, canvas, scrollX, scrollY } = this;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const visibleDataRows = [];
                const visibleDataCols = [];
                
                for (let i = Math.max(1, this.startRow); i <= this.endRow && i < this.rowCount; i++) {
                    visibleDataRows.push(i);
                }
                
                for (let i = Math.max(1, this.startCol); i <= this.endCol && i < this.colCount; i++) {
                    visibleDataCols.push(i);
                }

                // Render visible data cells
                for (const rowIndex of visibleDataRows) {
                    for (const colIndex of visibleDataCols) {
                        const cell = this.getCell(rowIndex, colIndex);
                        const x = this.getColumnPosition(colIndex) - scrollX;
                        const y = this.getRowPosition(rowIndex) - scrollY;
                        const width = this.getColumn(colIndex).getSize();
                        const height = this.getRow(rowIndex).getSize();

                        if (x + width >= 0 && y + height >= 0 && 
                            x < canvas.width && y < canvas.height) {
                            cell.draw(ctx, x, y, width, height, this.selection);
                        }
                    }
                }

                // Render visible row headers
                for (const rowIndex of visibleDataRows) {
                    const cell = this.getCell(rowIndex, 0);
                    const x = 0;
                    const y = this.getRowPosition(rowIndex) - scrollY;
                    const width = this.getColumn(0).getSize();
                    const height = this.getRow(rowIndex).getSize();

                    if (y + height >= 0 && y < canvas.height) {
                        cell.draw(ctx, x, y, width, height, this.selection);
                    }
                }

                // Render visible column headers
                for (const colIndex of visibleDataCols) {
                    const cell = this.getCell(0, colIndex);
                    const x = this.getColumnPosition(colIndex) - scrollX;
                    const y = 0;
                    const width = this.getColumn(colIndex).getSize();
                    const height = this.getRow(0).getSize();

                    if (x + width >= 0 && x < canvas.width) {
                        cell.draw(ctx, x, y, width, height, this.selection);
                    }
                }

                // Render corner cell
                const cornerCell = this.getCell(0, 0);
                const cornerWidth = this.getColumn(0).getSize();
                const cornerHeight = this.getRow(0).getSize();
                cornerCell.draw(ctx, 0, 0, cornerWidth, cornerHeight, this.selection);

                // Draw selection outline
                this.drawSelectionOutline();

                // Draw frozen header borders
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(cornerWidth, 0);
                ctx.lineTo(cornerWidth, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, cornerHeight);
                ctx.lineTo(canvas.width, cornerHeight);
                ctx.stroke();
            }

            drawSelectionOutline() {
                const currentSelection = this.selection.getCurrentSelection();
                if (!currentSelection) return;

                const ctx = this.ctx;
                const { startRow, startCol, endRow, endCol } = currentSelection;
                
                const startX = this.getColumnPosition(startCol) - this.scrollX;
                const startY = this.getRowPosition(startRow) - this.scrollY;
                const endX = this.getColumnPosition(endCol + 1) - this.scrollX;
                const endY = this.getRowPosition(endRow + 1) - this.scrollY;

                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                ctx.strokeRect(startX, startY, endX - startX, endY - startY);
                
                const handleSize = 6;
                ctx.fillStyle = '#2196F3';
                ctx.fillRect(endX - handleSize/2, endY - handleSize/2, handleSize, handleSize);
            }

            updateInfoDisplay() {
                const selectionInfo = this.selection.getSelectionInfo();
                const statsInfo = this.calculator.getFormattedStats(this, this.selection);
                
                if (statsInfo === "No numeric values selected") {
                    this.info.textContent = selectionInfo;
                } else {
                    this.info.textContent = `${selectionInfo} | ${statsInfo}`;
                }
            }
        }

        // Initialize the grid
        const grid = new CanvasGrid('grid', 100000, 500);

        // Try to load data automatically
        grid.loadData().catch(() => {
            // If data.json doesn't exist, just show ready state
            grid.info.textContent = 'Ready - Grid initialized';
        });
    </script>
</body>

</html>